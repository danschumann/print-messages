// Generated by CoffeeScript 1.6.3
(function() {
  var method, n, printMessages, _ref,
    __slice = [].slice;

  require('colors');

  printMessages = {};

  printMessages.color = function(color) {
    return function() {
      var arg, n, _i, _len, _results;
      console.log('');
      _results = [];
      for (n = _i = 0, _len = arguments.length; _i < _len; n = ++_i) {
        arg = arguments[n];
        if ('string' === typeof arg) {
          _results.push(console.log(arg[!n ? color : 'white']));
        } else if (arg) {
          _results.push(console.log(arg));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  };

  _ref = {
    log: printMessages.color('cyan'),
    success: printMessages.color('green'),
    warn: printMessages.color('yellow'),
    error: printMessages.color('red'),
    node: function(msg, err, result) {
      if (err) {
        return this.error(msg, err);
      } else {
        return this.success(msg, result);
      }
    },
    crash: function() {
      var args, err,
        _this = this;
      err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      process.nextTick(function() {
        var reason, _ref, _ref1;
        reason = (_ref = (_ref1 = err != null ? err.msg : void 0) != null ? _ref1 : err) != null ? _ref : 'Unknown error';
        return printMessages.error.apply(printMessages, [reason, err != null ? err.stack : void 0].concat(__slice.call(args)));
      });
      if ('string' === typeof err) {
        throw new Error(err);
      }
      throw err;
    },
    crash_cb: function() {
      var msgs;
      msgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return function(err) {
        return printMessages.crash.apply(printMessages, [err].concat(__slice.call(msgs)));
      };
    },
    promise: function(msg, promise) {
      var _this = this;
      return promise.then(function(result) {
        return printMessages.success(msg, result);
      }, function(err) {
        return printMessages.error(msg, err);
      });
    },
    node_cb: function(msg) {
      return function() {
        return printMessages.node.apply(printMessages, [msg].concat(__slice.call(arguments)));
      };
    },
    log_cb: function(msg) {
      return function() {
        return printMessages.log.apply(printMessages, [msg].concat(__slice.call(arguments)));
      };
    },
    success_cb: function(msg) {
      return function() {
        return printMessages.success.apply(printMessages, [msg].concat(__slice.call(arguments)));
      };
    },
    warn_cb: function(msg) {
      return function() {
        return printMessages.warn.apply(printMessages, [msg].concat(__slice.call(arguments)));
      };
    },
    error_cb: function(msg) {
      return function() {
        return printMessages.error.apply(printMessages, [msg].concat(__slice.call(arguments)));
      };
    }
  };
  for (n in _ref) {
    method = _ref[n];
    printMessages[n] = method;
  }

  module.exports = printMessages;

}).call(this);
